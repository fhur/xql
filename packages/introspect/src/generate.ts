import { ColumnDefProperties } from '@synthql/queries';
import $RefParser from '@apidevtools/json-schema-ref-parser';
import {
    DomainDetails,
    EnumDetails,
    extractSchemas,
    Schema,
    TableColumn,
    TableColumnType,
    TableDetails,
    ViewColumn,
    ViewDetails,
} from 'extract-pg-schema';
import { compile, JSONSchema } from 'json-schema-to-typescript';
import fs from 'fs';
import path from 'path';

type TableOrView = TableDetails | ViewDetails;
type TableOrViewColumn = TableColumn | ViewColumn;

interface TableDefTransformer {
    test: (tableDetails: TableOrView) => boolean;
    transform: (tableColumn: TableOrViewColumn) => Partial<ColumnDefProperties>;
}

interface GenerateProps {
    /**
     * The database connection string e.g. `postgresql://user:password@localhost:5432/db`
     */
    connectionString: string;
    /**
     * The schemas to include in generation e.g. `['public']`
     */
    includeSchemas: string[];
    /**
     * The default schema to use e.g. `public`. This is similar to the `search_path` in PostgreSQL
     */
    defaultSchema: string;
    /**
     * The tables to include in generation e.g. `['users']`
     */
    includeTables?: string[];
    /**
     * The tables and/or views to exclude from generation.
     * e.g. `['agents', 'suppliers', 'agent_supplier']`
     */
    excludeTablesAndViews?: string[];
    /**
     * Custom transformers that can be used to modify/extend
     * the default generation data for the applicable table columns
     */
    tableDefTransformers?: Array<TableDefTransformer>;
    /**
     * The output directory for the generated files e.g. `src/generated`
     */
    outDir: string;
    /**
     * A function to format the generated files, usually Prettier
     */
    formatter?: (str: string) => Promise<string>;
    SECRET_INTERNALS_DO_NOT_USE_queriesImportLocation?: string;
}

export async function generate({
    connectionString,
    includeSchemas,
    defaultSchema,
    includeTables = [],
    excludeTablesAndViews = [],
    tableDefTransformers = [],
    outDir,
    formatter = async (str) => str,
    SECRET_INTERNALS_DO_NOT_USE_queriesImportLocation = '@synthql/queries',
}: GenerateProps) {
    async function writeFormattedFile(path: string, content: string) {
        fs.writeFileSync(path, await formatter(content));
    }

    const { stderr } = process;

    // Step 1: Use pg-extract-schema to get the schema.
    const pgExtractSchema = await extractSchemas(
        {
            connectionString,
        },
        {
            schemas: includeSchemas,
            resolveViews: false,
            onProgressStart: (total) => {
                stderr.write(
                    `⏱️  Extracting ${total} types, this may take a while`,
                );
                stderr.write('\n');
            },
            onProgress: () => {
                stderr.write('.');
            },
            onProgressEnd: () => console.log('✅ Done extracting types.'),
        },
    );

    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir, { recursive: true });
    }

    // Step 2: Convert the pg-extract-schema schema to a JSON Schema.
    const schemaWithRefs: JSONSchema = createRootJsonSchema(pgExtractSchema, {
        defaultSchema,
        includeTables,
        excludeTablesAndViews,
        tableDefTransformers,
    });

    /**
     * Step 3: Compile the JSON schema into TypeScript files.
     * Generate types from the schema with refs.
     * This leads to a more readable output as the types are not inlined.
     */
    const db = await compile(schemaWithRefs, 'DB', {
        additionalProperties: false,
        unreachableDefinitions: false,
    });

    writeFormattedFile(path.join(outDir, 'db.ts'), db);

    /**
     * Generate types from the schema without refs.
     * This leads to a more compact output as the types are inlined.
     */
    const schemaWithoutRefs = await $RefParser.dereference(schemaWithRefs);

    writeFormattedFile(
        path.join(outDir, 'schema.ts'),
        [
            `// @ts-nocheck`,
            `// This file is generated by introspect. Do not edit it manually.`,
            `import { Schema } from '${SECRET_INTERNALS_DO_NOT_USE_queriesImportLocation}';`,
            `import { DB } from './db';`,
            `export const schema: Schema<DB> = ${JSON.stringify(schemaWithoutRefs, null, 2)};`,
        ].join('\n'),
    );

    writeFormattedFile(
        path.join(outDir, 'index.ts'),
        [
            `// This file is generated by introspect. Do not edit it manually.`,
            `import { query } from '${SECRET_INTERNALS_DO_NOT_USE_queriesImportLocation}';`,
            `import { DB } from './db';`,
            `import { schema } from './schema';`,
            `export type { DB } from './db';`,
            `export { schema } from './schema';`,
            `export const from = query<DB>(schema).from;`,
        ].join('\n'),
    );

    return {
        schema: schemaWithoutRefs,
    };
}

function createTypeDefId(type: {
    fullName: string;
    kind: TableColumnType['kind'];
}) {
    if (type.kind === 'base') {
        return type.fullName;
    }

    return `${type.fullName}.${type.kind}`;
}

function createTableDefId(type: TableOrView, defaultSchema: string) {
    if (type.schemaName === defaultSchema) {
        return `table_${type.name}`;
    }

    return `table_${type.schemaName}_${type.name}`;
}

function createTableJsonSchema(
    table: TableOrView,
    tableDefTransformer?: TableDefTransformer,
): JSONSchema {
    const empty: Record<string, any> = {};

    const columns = table.columns
        .sort((a, b) => a.name.localeCompare(b.name))
        .reduce((acc, column) => {
            const type = createColumnTypeDefOrRef(column);

            acc[column.name] = {
                type: 'object',
                description:
                    column.comment ??
                    [
                        'Column details:',
                        '',
                        `- Schema: ${table.schemaName}`,
                        `- Table: ${table.name}`,
                        `- Column: ${column.name}`,
                        `- PG type: ${column.type.fullName}`,
                        `- PG kind: ${column.type.kind}`,
                        `- Nullable: ${column.isNullable}`,
                        `- Generated: ${column.generated}`,
                    ].join('\n'),
                properties: {
                    type,
                    // A constant value of true
                    selectable: { type: 'boolean', const: true },
                    includable: { type: 'boolean', const: true },
                    whereable: { type: 'boolean', const: true },
                    nullable: {
                        type: 'boolean',
                        const: column.isNullable ?? false,
                    },
                    isPrimaryKey: {
                        type: 'boolean',
                        const: column.isPrimaryKey ?? false,
                    },
                    // For each column, we want to identify if any override
                    // properties were passed, and replace them if so
                    // Otherwise, we generate the property as usual
                    ...tableDefTransformer?.transform(column),
                },
                required: [
                    'type',
                    'selectable',
                    'includable',
                    'whereable',
                    'nullable',
                    'isPrimaryKey',
                ],
                additionalProperties: false,
            };

            return acc;
        }, empty);

    return {
        type: 'object',
        description:
            table.comment ??
            [
                'Table details:',
                '',
                `- Schema: ${table.schemaName}`,
                `- Table: ${table.name}`,
            ].join('\n'),
        properties: {
            columns: {
                type: 'object',
                properties: columns,
                required: table.columns.map((column) => column.name),
                additionalProperties: false,
            },
        },
        required: ['columns'],
        additionalProperties: false,
    };
}

function isExpandedTypeAnArray(expandedType: string): boolean {
    return expandedType.endsWith('[]');
}

function createArrayDef(expandedType: string, fullName: string): JSONSchema {
    const items = expandedType.split('[]');

    // 1. Starting at the rightmost,
    // create an array schema def,
    // and move leftwards

    // 2. Once the string left is
    // an object pg type, embed
    // the object properties

    if (items[items.length - 1] === fullName) {
        return createWellKnownDefs()[fullName];
    } else if (items[items.length - 1] === '') {
        return {
            id: expandedType,
            type: 'array',
            items: createArrayDef(items.slice(0, -1).join('[]'), fullName),
        };
    }

    console.warn(
        `No type definition found for the pg_type: ${items[items.length - 1]}`,
    );

    // return `unknown` otherwise
    return {};
}

function createColumnTypeDefOrRef(column: TableOrViewColumn) {
    // TODO(fhur): for now, when a type is composite use the "unknown" type.
    // In the future we should add support for composite types.
    if (column.type.kind === 'composite') {
        return {};
    } else if (isExpandedTypeAnArray(column.expandedType)) {
        return createArrayDef(column.expandedType, column.type.fullName);
    }

    return {
        $ref: `#/$defs/${createTypeDefId(column.type)}`,
    };
}

function createRootJsonSchema(
    schemas: Record<string, Schema>,
    {
        defaultSchema,
        includeTables,
        excludeTablesAndViews,
        tableDefTransformers,
    }: {
        defaultSchema: string;
        includeTables: string[];
        excludeTablesAndViews: string[];
        tableDefTransformers: Array<TableDefTransformer>;
    },
): JSONSchema {
    const allTables: TableOrView[] = Object.values(schemas).flatMap(
        (schema) => schema.tables,
    );
    const allViews: TableOrView[] = Object.values(schemas).flatMap(
        (schema) => schema.views,
    );

    const allTablesAndViews: TableOrView[] = allTables.concat(allViews);

    // Check if a list of tables/views is passed, and if so, use as filter
    // The logic here is currently that `exclusion` takes precedence,
    // so if a table is both included & excluded, the exclude takes precedence,
    // so the table will NOT be included in the schema
    let tables: TableOrView[] = allTablesAndViews;

    if (includeTables.length > 0) {
        tables = tables.filter((tableOrView) =>
            includeTables.includes(tableOrView.name),
        );
    }

    if (excludeTablesAndViews.length > 0) {
        tables = tables
            .filter(
                (tableOrView) =>
                    !excludeTablesAndViews.includes(tableOrView.name),
            )
            .sort((a, b) => a.name.localeCompare(b.name));
    }

    const enums = Object.values(schemas)
        .flatMap((schema) => {
            return schema.enums;
        })
        .sort((a, b) => a.name.localeCompare(b.name));

    const domains = Object.values(schemas)
        .flatMap((schema) => {
            return schema.domains;
        })
        .sort((a, b) => a.name.localeCompare(b.name));

    return {
        $schema: 'https://json-schema.org/draft/2020-12/schema',
        type: 'object',
        description: "Your database's schema",
        properties: tables
            .map((table) => {
                return {
                    [fullTableName(table, defaultSchema)]: {
                        $ref: `#/$defs/${createTableDefId(table, defaultSchema)}`,
                    },
                };
            })
            .reduce((acc, table) => {
                return { ...acc, ...table };
            }, {}),
        required: tables.map((table) => fullTableName(table, defaultSchema)),
        additionalProperties: false,
        $defs: {
            ...createTableDefs(tables, defaultSchema, tableDefTransformers),
            ...createWellKnownDefs(),
            ...createEnumJsonSchema(enums),
            ...createDomainJsonSchema(domains),
        },
    };
}

function fullTableName(table: TableOrView, defaultSchema: string) {
    if (table.schemaName === defaultSchema) {
        return table.name;
    }

    return `${table.schemaName}.${table.name}`;
}

function createTableDefs(
    tables: TableOrView[],
    defaultSchema: string,
    tableDefTransformers: Array<TableDefTransformer>,
): Record<string, JSONSchema> {
    const empty: Record<string, JSONSchema> = {};

    return tables.reduce((acc, table) => {
        const tableDefTransformer = tableDefTransformers.find(
            (tableDefTransformer) => tableDefTransformer.test(table),
        );

        acc[createTableDefId(table, defaultSchema)] = createTableJsonSchema(
            table,
            tableDefTransformer,
        );

        return acc;
    }, empty);
}

function createEnumJsonSchema(
    enums: EnumDetails[],
): Record<string, JSONSchema> {
    const empty: Record<string, JSONSchema> = {};

    return enums.reduce((acc, enumType) => {
        acc[
            createTypeDefId({
                kind: 'enum',
                fullName: `${enumType.schemaName}.${enumType.name}`,
            })
        ] = {
            id: createTypeDefId({
                kind: 'enum',
                fullName: `${enumType.schemaName}.${enumType.name}`,
            }),
            type: 'string',
            enum: enumType.values,
            description:
                enumType.comment ??
                `The ${enumType.name} enum from the ${enumType.schemaName} schema`,
        };

        return acc;
    }, empty);
}

function createDomainJsonSchema(
    domains: DomainDetails[],
): Record<string, JSONSchema> {
    const empty: Record<string, JSONSchema> = {};

    return domains.reduce((acc, domain) => {
        acc[
            createTypeDefId({
                kind: 'domain',
                fullName: `${domain.schemaName}.${domain.name}`,
            })
        ] = {
            id: domain.innerType,
            title: createTypeDefId({
                kind: 'domain',
                fullName: `${domain.schemaName}.${domain.name}`,
            }),
            type: domainType(domain.innerType),
            description:
                domain.comment ??
                `The ${domain.name} domain from the ${domain.schemaName} schema`,
        };

        return acc;
    }, empty);
}

function domainType(
    domainInnerType: DomainDetails['innerType'],
): JSONSchema['type'] {
    for (const [name, schema] of Object.entries(createWellKnownDefs())) {
        if (domainInnerType === name) {
            return schema.type;
        }
    }

    return 'any';
}

function createWellKnownDefs(): Record<string, JSONSchema> {
    return {
        'pg_catalog.bit': {
            id: 'pg_catalog.bit',
            type: 'string',
            description: 'A PG bit',
        },
        'pg_catalog.bool': {
            id: 'pg_catalog.bool',
            type: 'boolean',
            description: 'A PG bool',
        },
        'pg_catalog.box': {
            id: 'pg_catalog.box',
            type: 'string',
            description: 'A PG box',
        },
        'pg_catalog.bpchar': {
            id: 'pg_catalog.bpchar',
            type: 'string',
            description: 'A PG bpchar',
        },
        'pg_catalog.bytea': {
            id: 'pg_catalog.bytea',
            type: 'object',
            description: 'A PG bytea',
        },
        'pg_catalog.char': {
            id: 'pg_catalog.char',
            type: 'string',
            description: 'A PG char',
        },
        'pg_catalog.cidr': {
            id: 'pg_catalog.cidr',
            type: 'string',
            description: 'A PG cidr',
        },
        'pg_catalog.circle': {
            id: 'pg_catalog.circle',
            type: 'object',
            description: 'A PG circle',
            properties: {
                radius: {
                    type: 'number',
                },
                x: {
                    type: 'number',
                },
                y: {
                    type: 'number',
                },
            },
            required: ['radius', 'x', 'y'],
        },
        'pg_catalog.date': {
            id: 'pg_catalog.date',
            type: 'string',
            format: 'date',
            description: [
                'A PG date.',
                'Note that values of the PG date type,',
                'are returned as ISO 8601 strings from the database.',
                'This is because that is how they can be best',
                'accurately processed in JavaScript/TypeScript.',
                'To convert the string into a `Date` object,',
                'use `new Date(dateString)` or `Date.parse(dateString)`',
            ].join('\n'),
        },
        'pg_catalog.float4': {
            id: 'pg_catalog.float4',
            type: 'number',
            description: 'A PG float4',
        },
        'pg_catalog.float8': {
            id: 'pg_catalog.float8',
            type: 'number',
            description: 'A PG float8',
        },
        'pg_catalog.inet': {
            id: 'pg_catalog.inet',
            type: 'string',
            description: 'A PG inet',
        },
        'pg_catalog.int2': {
            id: 'pg_catalog.int2',
            type: 'integer',
            minimum: -32768,
            maximum: 32767,
            description: 'A PG int2',
        },
        'pg_catalog.int4': {
            id: 'pg_catalog.int4',
            type: 'integer',
            minimum: -2147483648,
            maximum: 2147483647,
            description: 'A PG int4',
        },
        'pg_catalog.int8': {
            id: 'pg_catalog.int8',
            type: 'string',
            description: 'A PG int8',
        },
        'pg_catalog.interval': {
            id: 'pg_catalog.interval',
            type: 'object',
            description: 'A PG interval',
        },
        'pg_catalog.json': {
            id: 'pg_catalog.json',
            type: 'object',
            description: 'A PG json',
        },
        'pg_catalog.jsonb': {
            id: 'pg_catalog.jsonb',
            type: 'object',
            description: 'A PG jsonb',
        },
        'pg_catalog.line': {
            id: 'pg_catalog.line',
            type: 'string',
            description: 'A PG line',
        },
        'pg_catalog.lseg': {
            id: 'pg_catalog.lseg',
            type: 'string',
            description: 'A PG lseg',
        },
        'pg_catalog.macaddr': {
            id: 'pg_catalog.macaddr',
            type: 'string',
            description: 'A PG macaddr',
        },
        'pg_catalog.macaddr8': {
            id: 'pg_catalog.macaddr8',
            type: 'string',
            description: 'A PG macaddr8',
        },
        'pg_catalog.money': {
            id: 'pg_catalog.money',
            type: 'string',
            description: [
                'A PG money.',
                'Note that values of the PG money type,',
                'are returned as strings from the database.',
                'This is because that is how they can be best',
                'accurately processed in JavaScript/TypeScript',
            ].join('\n'),
        },
        'pg_catalog.numeric': {
            id: 'pg_catalog.numeric',
            type: 'string',
            description: [
                'A PG numeric.',
                'Note that values of the PG numeric type,',
                'are returned as strings from the database.',
                'This is because that is how they can be best',
                'accurately processed in JavaScript/TypeScript',
            ].join('\n'),
        },
        'pg_catalog.path': {
            id: 'pg_catalog.path',
            type: 'string',
            description: 'A PG path',
        },
        'pg_catalog.pg_lsn': {
            id: 'pg_catalog.pg_lsn',
            type: 'string',
            description: 'A PG pg_lsn',
        },
        'pg_catalog.pg_snapshot': {
            id: 'pg_catalog.pg_snapshot',
            type: 'string',
            description: 'A PG pg_snapshot',
        },
        'pg_catalog.point': {
            id: 'pg_catalog.point',
            type: 'object',
            description: 'A PG point',
            properties: {
                x: {
                    type: 'number',
                },
                y: {
                    type: 'number',
                },
            },
            required: ['x', 'y'],
        },
        'pg_catalog.polygon': {
            id: 'pg_catalog.polygon',
            type: 'string',
            description: 'A PG polygon',
        },
        'pg_catalog.serial2': {
            id: 'pg_catalog.serial2',
            type: 'integer',
            minimum: 1,
            maximum: 32767,
            description: 'A PG serial2',
        },
        'pg_catalog.serial4': {
            id: 'pg_catalog.serial4',
            type: 'integer',
            minimum: 1,
            maximum: 2147483647,
            description: 'A PG serial4',
        },
        'pg_catalog.serial8': {
            id: 'pg_catalog.serial8',
            type: 'string',
            description: 'A PG serial8',
        },
        'pg_catalog.text': {
            id: 'pg_catalog.text',
            type: 'string',
            description: 'A PG text',
        },
        'pg_catalog.time': {
            id: 'pg_catalog.time',
            type: 'string',
            format: 'time',
            description: [
                'A PG time.',
                'Note that values of the PG time type,',
                'are returned as ISO 8601 strings from the database.',
                'This is because that is how they can be best',
                'accurately processed in JavaScript/TypeScript',
            ].join('\n'),
        },
        'pg_catalog.timestamp': {
            id: 'pg_catalog.timestamp',
            type: 'string',
            format: 'date-time',
            description: [
                'A PG timestamp.',
                'Note that values of the PG timestamp type,',
                'are returned as ISO 8601 strings from the database.',
                'This is because that is how they can be best',
                'accurately processed in JavaScript/TypeScript.',
                'To convert the string into a `Date` object,',
                'use `new Date(dateTimeString)` or `Date.parse(dateTimeString)`',
            ].join('\n'),
        },
        'pg_catalog.timestamptz': {
            id: 'pg_catalog.timestamptz',
            type: 'string',
            format: 'date-time',
            description: [
                'A PG timestamptz.',
                'Note that values of the PG timestamptz type,',
                'are returned as ISO 8601 strings from the database.',
                'This is because that is how they can be best',
                'accurately processed in JavaScript/TypeScript',
                'To convert the string into a `Date` object,',
                'use `new Date(dateTimeString)` or `Date.parse(dateTimeString)`',
            ].join('\n'),
        },
        'pg_catalog.timetz': {
            id: 'pg_catalog.timetz',
            type: 'string',
            format: 'time',
            description: [
                'A PG timetz.',
                'Note that values of the PG timetz type,',
                'are returned as ISO 8601 strings from the database.',
                'This is because that is how they can be best',
                'accurately processed in JavaScript/TypeScript.',
                'To convert the string into a `Date` object,',
                'use `new Date(timeString)` or `Date.parse(timeString)`',
            ].join('\n'),
        },
        'pg_catalog.tsquery': {
            id: 'pg_catalog.tsquery',
            type: 'string',
            description: 'A PG tsquery',
        },
        'pg_catalog.tsvector': {
            id: 'pg_catalog.tsvector',
            type: 'string',
            description: 'A PG tsvector',
        },
        'pg_catalog.txid_snapshot': {
            id: 'pg_catalog.txid_snapshot',
            type: 'string',
            description: 'A PG txid_snapshot',
        },
        'pg_catalog.uuid': {
            id: 'pg_catalog.uuid',
            type: 'string',
            format: 'uuid',
            description: 'A PG uuid',
        },
        'pg_catalog.varbit': {
            id: 'pg_catalog.varbit',
            type: 'string',
            description: 'A PG varbit',
        },
        'pg_catalog.varchar': {
            id: 'pg_catalog.varchar',
            type: 'string',
            description: 'A PG varchar',
        },
        'pg_catalog.xml': {
            id: 'pg_catalog.xml',
            type: 'string',
            description: 'A PG xml',
        },
    };
}
